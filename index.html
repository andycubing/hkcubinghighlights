<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>WCA Daily Cube Tracker (HK Focus)</title>
    <!-- Load Tailwind CSS -->
    <script src="https://cdn.tailwindcss.com"></script>
    <link href="https://fonts.googleapis.com/css2?family=Inter:wght@400;600;700&display=swap" rel="stylesheet">
    <style>
        body {
            font-family: 'Inter', sans-serif;
            background-color: #f7f7f7;
            min-height: 100vh;
        }
        .container {
            max-width: 1200px;
        }
        .card {
            box-shadow: 0 4px 6px -1px rgba(0, 0, 0, 0.1), 0 2px 4px -2px rgba(0, 0, 0, 0.06);
            transition: transform 0.3s ease;
        }
        .loader {
            border-top-color: #3b82f6;
            -webkit-animation: spin 1s ease-in-out infinite;
            animation: spin 1s ease-in-out infinite;
            border-radius: 50%;
            border: 4px solid rgba(59, 130, 246, 0.2);
            border-top: 4px solid #3b82f6;
            width: 40px;
            height: 40px;
        }
        @keyframes spin {
            to { transform: rotate(360deg); }
        }
        /* Mobile optimization for tables */
        @media (max-width: 640px) {
            .table-sm-stack tr {
                display: block;
                margin-bottom: 0.75rem;
                border: 1px solid #e5e7eb;
                border-radius: 0.5rem;
            }
            .table-sm-stack td {
                display: flex;
                justify-content: space-between;
                padding: 0.5rem 1rem;
                border-bottom: 1px dashed #e5e7eb;
            }
            .table-sm-stack td:last-child {
                border-bottom: none;
            }
            .table-sm-stack th {
                display: none; /* Hide headers on small screens */
            }
            .table-sm-stack td::before {
                content: attr(data-label);
                font-weight: 600;
                color: #4b5563;
                margin-right: 0.5rem;
            }
        }
    </style>
</head>
<body class="p-4 md:p-8">

    <div class="container mx-auto">
        <header class="text-center py-6 mb-8 bg-white rounded-xl card border-b-4 border-blue-500">
            <h1 class="text-3xl md:text-4xl font-bold text-gray-800">WCA Daily Competitor Tracker</h1>
            <p id="dateRangeDisplay" class="text-gray-500 mt-1 text-sm md:text-base"></p>
        </header>

        <main class="grid grid-cols-1 lg:grid-cols-2 gap-8">
            <!-- UPCOMING COMPETITIONS (Future) -->
            <section class="card bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-semibold text-blue-600 mb-4 border-b pb-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline mr-2 text-yellow-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M12 8v4l3 3m6-3a9 9 0 11-18 0 9 9 0 0118 0z" />
                    </svg>
                    Upcoming HK Competitors (Next 28 Days)
                </h2>
                <p class="text-xs text-gray-500 mb-4">Competitors from Hong Kong registered for an event in which they are Nationally Ranked 10 or better.</p>
                <div id="upcoming-results">
                    <div id="upcoming-loader" class="flex justify-center items-center py-10">
                        <div class="loader"></div>
                    </div>
                </div>
            </section>

            <!-- RECENT TOP PERFORMANCES (Past) -->
            <section class="card bg-white p-6 rounded-xl shadow-lg">
                <h2 class="text-2xl font-semibold text-blue-600 mb-4 border-b pb-2">
                    <svg xmlns="http://www.w3.org/2000/svg" class="h-6 w-6 inline mr-2 text-green-500" fill="none" viewBox="0 0 24 24" stroke="currentColor">
                        <path stroke-linecap="round" stroke-linejoin="round" stroke-width="2" d="M9 12l2 2 4-4m5.618-4.016A11.955 11.955 0 0112 2.944a11.955 11.955 0 01-8.618 3.042 12.036 12.036 0 00-1.63 7.558 12.036 12.036 0 001.63 7.558 11.955 11.955 0 018.618 3.042 12.036 12.036 0 001.63-7.558 12.036 12.036 0 00-1.63-7.558z" />
                    </svg>
                    Recent Top PBs Achieved (Last 28 Days)
                </h2>
                <p class="text-xs text-gray-500 mb-4">Competitors who achieved a new personal best that is Hong Kong National Rank 10 or World Rank 5 or better.</p>
                <div id="recent-results">
                    <div id="recent-loader" class="flex justify-center items-center py-10">
                        <div class="loader"></div>
                    </div>
                </div>
            </section>
        </main>

        <footer class="text-center mt-12 text-gray-400 text-sm">
            Data sourced from the World Cube Association (WCA) API. It gonna load forever because I suck.
        </footer>
    </div>

    <script>
        const API_BASE_URL = "https://www.worldcubeassociation.org/api/v0";
        const WCA_EVENTS = ["222", "333", "444", "555", "666", "777", "333oh", "333bf", "333mbf", "333fm", "444bf", "555bf", "minx", "clock", "pyram", "skewb", "sq1"];
        const EVENT_NAMES = {
            "222": "2x2x2", "333": "3x3x3", "444": "4x4x4", "555": "5x5x5", "666": "6x6x6", "777": "7x7x7",
            "333oh": "3x3 OH", "333bf": "3x3 BLD", "333mbf": "3x3 MBLD", "333fm": "3x3 FMC",
            "444bf": "4x4 BLD", "555bf": "5x5 BLD", "minx": "Megaminx", "clock": "Clock",
            "pyram": "Pyraminx", "skewb": "Skewb", "sq1": "Square-1"
        };
        const HK_ISO_CODE = 'HK';

        // --- Utility Functions for Date and API ---

        function formatDate(date) {
            return date.toISOString().split('T')[0];
        }

        async function fetchWithRetry(url) {
            for (let i = 0; i < 3; i++) { // 3 attempts
                try {
                    const response = await fetch(url);
                    if (response.ok) {
                        return await response.json();
                    }
                    if (response.status === 429) { // Rate limit
                        console.warn(`Rate limit hit. Retrying in ${2 ** i}s...`);
                        await new Promise(r => setTimeout(r, (2 ** i) * 1000));
                        continue;
                    }
                    throw new Error(`HTTP error! status: ${response.status}`);
                } catch (error) {
                    if (i === 2) throw error;
                    console.error(`Fetch failed, retrying: ${error}`);
                    await new Promise(r => setTimeout(r, (2 ** i) * 1000));
                }
            }
            // If all retries fail, return undefined
            return undefined;
        }

        function cleanName(name) {
            return name.replace(/\s*\(.*?\)/, '').trim();
        }
        
        // --- WCA Time Formatting Functions (Translated from Python) ---

        function decodeMbldAttempt(value) {
            if (value <= 0) {
                return { solved: 0, attempted: 0, centiseconds: null };
            }
            const missed = value % 100;
            const seconds = Math.floor(value / 100) % 100000;
            const points = 99 - (Math.floor(value / 10000000) % 100);
            const solved = points + missed;
            const attempted = solved + missed;
            const centiseconds = seconds === 99999 ? null : seconds * 100;
            return { solved, attempted, centiseconds };
        }

        function centisecondsToTimeFormat(value) {
            if (value === null) {
                return "DNF";
            }
            const seconds = value / 100;
            if (seconds >= 60) {
                const minutes = Math.floor(seconds / 60);
                const secondsRemainder = (seconds % 60).toFixed(2);
                return `${minutes}:${secondsRemainder.padStart(5, '0')}`;
            }
            return `${seconds.toFixed(2)}`;
        }

        function formatMbldAttempt(attempt) {
            const { solved, attempted, centiseconds } = decodeMbldAttempt(attempt);
            if (centiseconds === null) {
                return "DNF";
            }
            const timeFormat = centisecondsToTimeFormat(centiseconds);
            return `${solved}/${attempted} ${timeFormat}`;
        }

        function formatTime(value, eventId, resultType) {
            if (value <= 0) return "DNF";
            if (eventId === "333mbf" && resultType === "single") {
                return formatMbldAttempt(value);
            }
            if (eventId === "333fm" && resultType === "single") {
                return String(value);
            }
            return centisecondsToTimeFormat(value);
        }

        // --- Core Data Fetching Functions ---

        async function getCompetitions(startDate, endDate) {
            const url = `${API_BASE_URL}/competitions?sort=start_date&start=${startDate}&end=${endDate}&per_page=100`;
            try {
                const data = await fetchWithRetry(url);
                // Ensure data is an array, otherwise return an empty array
                return Array.isArray(data) ? data : []; 
            } catch (e) {
                console.error("Failed to fetch competitions:", e);
                // Always return an empty array on failure
                return [];
            }
        }

        async function getCompetitionWCIF(comp_id) {
            const url = `${API_BASE_URL}/competitions/${comp_id}/wcif/public`;
            try {
                // Fetch data, which might be undefined/null on a failed fetch
                const data = await fetchWithRetry(url);
                
                // If data is null/undefined, return an empty array to prevent attempting to read 'persons' on it.
                if (!data) return [];
                
                // Safely access persons and default to an empty array if not present.
                // WCIF structure is {..., persons: [...]}
                return data.persons ?? [];

            } catch (e) {
                // Log the competition ID for context when logging the error
                console.error(`Failed to fetch WCIF for ${comp_id}:`, e);
                return [];
            }
        }

        async function getCompetitionResults(comp_id) {
            const url = `${API_BASE_URL}/competitions/${comp_id}/results`;
            try {
                const data = await fetchWithRetry(url);
                return Array.isArray(data) ? data : [];
            } catch (e) {
                console.error(`Failed to fetch results for ${comp_id}:`, e);
                return [];
            }
        }

        // --- Section 1: Upcoming Competitions (Next 14 Days) ---

        async function fetchUpcomingCompetitors(startDate, endDate) {
            const competitions = await getCompetitions(startDate, endDate);
            
            // Safety check: ensure competitions is an array before iterating
            if (!Array.isArray(competitions)) {
                console.error("Competitions data is not iterable.");
                displayUpcomingResults([], startDate, endDate);
                return;
            }

            let hkCompetitors = [];

            for (const comp of competitions) {
                if (!comp.id) continue;

                // getCompetitionWCIF now guarantees to return an array or []
                const persons = await getCompetitionWCIF(comp.id);
                
                // Determine competition date range
                const compDate = comp.start_date === comp.end_date 
                    ? comp.start_date 
                    : `${comp.start_date} - ${comp.end_date}`;

                for (const person of persons) {
                    // Check HK, accepted registration status, and check for personalBests data
                    if (
                        person.countryIso2 === HK_ISO_CODE &&
                        person.registration &&
                        person.registration.status === 'accepted' &&
                        person.personalBests &&
                        person.wcaId // Ensure we have a WCA ID for the link
                    ) {
                        const registeredEvents = person.registration.eventIds || [];
                        let topEvents = [];
                        
                        // Check PB for national rank <= 10
                        for (const record of person.personalBests) {
                            if (registeredEvents.includes(record.eventId) && WCA_EVENTS.includes(record.eventId)) {
                                if (record.nationalRanking !== null && record.nationalRanking !== undefined && record.nationalRanking <= 10) {
                                    topEvents.push(record.eventId);
                                }
                            }
                        }

                        if (topEvents.length > 0) {
                            hkCompetitors.push({
                                name: cleanName(person.name),
                                wcaId: person.wcaId, // Include WCA ID for linking
                                competition: comp.name,
                                compId: comp.id, // Include Comp ID for linking
                                competitionDate: compDate,
                                events: Array.from(new Set(topEvents)).sort().map(e => EVENT_NAMES[e]).join(', ')
                            });
                        }
                    }
                }
            }

            // Remove duplicates (same competitor registered for multiple events in the same comp)
            const uniqueCompetitors = Array.from(new Map(
                hkCompetitors.map(item => [`${item.name}-${item.competition}`, item])
            ).values()).sort((a, b) => a.competitionDate.localeCompare(b.competitionDate));

            displayUpcomingResults(uniqueCompetitors, futureStartDate, futureEndDate);
        }

        function displayUpcomingResults(data, startDate, endDate) {
            const container = document.getElementById('upcoming-results');
            container.innerHTML = ''; // Clear loader

            if (data.length === 0) {
                container.innerHTML = `<p class="text-gray-500 italic p-4 bg-gray-50 rounded-lg">No top HK competitors found registered in competitions from ${startDate} to ${endDate}.</p>`;
                return;
            }

            // Define headers for mobile display
            const headers = {
                'Name': 'Name',
                'Competition': 'Competition',
                'Competition Date': 'Date',
                'Highlighted Events': 'Top 10 Events'
            };

            let html = `<div class="overflow-x-auto">
                <table class="min-w-full divide-y divide-gray-200 table-sm-stack">
                    <thead class="bg-gray-50 hidden sm:table-header-group">
                        <tr>
                            <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${headers.Name}</th>
                            <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${headers.Competition}</th>
                            <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${headers['Competition Date']}</th>
                            <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${headers['Highlighted Events']}</th>
                        </tr>
                    </thead>
                    <tbody class="bg-white divide-y divide-gray-200">`;

            data.forEach(item => {
                const wcaProfileUrl = `https://www.worldcubeassociation.org/persons/${item.wcaId}`;
                const competitionUrl = `https://www.worldcubeassociation.org/competitions/${item.compId}`;
                
                html += `
                    <tr class="hover:bg-blue-50">
                        <td class="px-3 py-2 sm:py-4 whitespace-nowrap sm:whitespace-normal text-sm font-medium" data-label="${headers.Name}">
                            <a href="${wcaProfileUrl}" target="_blank" class="text-blue-700 hover:text-blue-900 font-semibold">${item.name}</a>
                        </td>
                        <td class="px-3 py-2 sm:py-4 whitespace-nowrap sm:whitespace-normal text-sm" data-label="${headers.Competition}">
                            <a href="${competitionUrl}" target="_blank" class="text-gray-700 hover:text-gray-900">${item.competition}</a>
                        </td>
                        <td class="px-3 py-2 sm:py-4 whitespace-nowrap sm:whitespace-normal text-sm text-gray-500" data-label="${headers['Competition Date']}">${item.competitionDate}</td>
                        <td class="px-3 py-2 sm:py-4 whitespace-normal text-sm text-blue-600 font-semibold" data-label="${headers['Highlighted Events']}">${item.events}</td>
                    </tr>
                `;
            });

            html += `</tbody></table></div>`;
            container.innerHTML = html;
        }


        // --- Section 2: Recent Top Performances (Last 7 Days) ---

        async function fetchRecentPBs(startDate, endDate) {
            const competitions = await getCompetitions(startDate, endDate);
            
            // Safety check: ensure competitions is an array before iterating
            if (!Array.isArray(competitions)) {
                console.error("Competitions data is not iterable.");
                displayRecentResults([], [], startDate, endDate);
                return;
            }
            
            let hkPerformances = [];
            let worldPerformances = [];

            for (const comp of competitions) {
                if (!comp.id) continue;
                
                const compId = comp.id;
                
                // Determine competition date range
                const compDate = comp.start_date === comp.end_date 
                    ? comp.start_date 
                    : `${comp.start_date} - ${comp.end_date}`;
                
                // Fetching results and persons concurrently for performance
                const [results, persons] = await Promise.all([
                    getCompetitionResults(compId),
                    getCompetitionWCIF(compId)
                ]);

                // getCompetitionWCIF and getCompetitionResults now guarantee to return an array or [].
                if (!results || !persons) continue;

                const personalBests = new Map();
                persons.forEach(person => {
                    if (person.wcaId && person.personalBests) {
                        personalBests.set(person.wcaId, person.personalBests);
                    }
                });

                for (const result of results) {
                    const wcaId = result.wca_id;
                    if (!wcaId || !personalBests.has(wcaId) || !WCA_EVENTS.includes(result.event_id)) continue;
                    
                    const competitorPBs = personalBests.get(wcaId);
                    const eventId = result.event_id;
                    const eventName = EVENT_NAMES[eventId];

                    // Helper to check if a result (single or average) matches a PB
                    const checkPB = (type, resultValue) => {
                        if (resultValue <= 0) return null;
                        
                        const pbRecord = competitorPBs.find(pb => 
                            pb.eventId === eventId && pb.type === type && pb.best === resultValue
                        );
                        
                        if (pbRecord) {
                            // Null/undefined checks for rankings
                            const natRank = pbRecord.nationalRanking;
                            const worldRank = pbRecord.worldRanking;

                            // Default to a high number if ranking is missing, so checks fail
                            const safeNatRank = (natRank === null || natRank === undefined) ? Infinity : natRank;
                            const safeWorldRank = (worldRank === null || worldRank === undefined) ? Infinity : worldRank;

                            const formattedResult = formatTime(resultValue, eventId, type);
                            return {
                                type,
                                result: formattedResult,
                                nationalRanking: safeNatRank,
                                worldRanking: safeWorldRank
                            };
                        }
                        return null;
                    };

                    const singleMatch = checkPB('single', result.best);
                    const averageMatch = checkPB('average', result.average);

                    // 1. Check HK Top 10 National PBs
                    if (result.country_iso2 === HK_ISO_CODE) {
                        [singleMatch, averageMatch]
                            .filter(m => m && m.nationalRanking <= 10 && m.nationalRanking !== Infinity)
                            .forEach(match => {
                                hkPerformances.push({
                                    name: cleanName(result.name),
                                    event: eventName,
                                    competitionDate: compDate, // New: Added date
                                    typeResult: `${match.type === 'single' ? 'Single' : 'Average'} ${match.result}`,
                                    rankingStr: `NR${match.nationalRanking}`
                                });
                            });
                    }

                    // 2. Check Top 5 World PBs (Global competitors)
                    [singleMatch, averageMatch]
                        .filter(m => m && m.worldRanking <= 5 && m.worldRanking !== Infinity)
                        .forEach(match => {
                            worldPerformances.push({
                                name: cleanName(result.name),
                                event: eventName,
                                competitionDate: compDate, // New: Added date
                                typeResult: `${match.type === 'single' ? 'Single' : 'Average'} ${match.result}`,
                                rankingStr: `WR${match.worldRanking}`
                            });
                        });
                }
            }

            displayRecentResults(hkPerformances, worldPerformances, pastStartDate, pastEndDate);
        }

        function displayRecentResults(hkData, worldData, startDate, endDate) {
            const container = document.getElementById('recent-results');
            container.innerHTML = ''; // Clear loader
            
            let html = '';
            let allDataFound = false;

            // Helper to render a table
            const renderTable = (data, title, rankingCol) => {
                // Deduplicate the data based on Name, Event, Date, and Type&Result
                const uniqueData = Array.from(new Map(
                    data.map(item => [`${item.name}-${item.event}-${item.competitionDate}-${item.typeResult}`, item])
                ).values());

                if (uniqueData.length === 0) {
                    return `<p class="text-sm text-gray-400 mt-2">${title}: No PBs found.</p>`;
                }
                
                allDataFound = true; // Mark that at least one result set was found

                // Sort by the ranking number (e.g., 1 before 2)
                uniqueData.sort((a, b) => 
                    parseInt(a.rankingStr.substring(2)) - parseInt(b.rankingStr.substring(2))
                );

                // Define headers for mobile display
                const headers = {
                    'Name': 'Name',
                    'Event': 'Event',
                    'Date': 'Date',
                    'Type&Result': 'Result (PB)',
                    'Ranking': rankingCol
                };

                let tableHtml = `<h3 class="text-lg font-bold mt-6 mb-2 text-gray-700">${title}</h3>`;
                tableHtml += `<div class="overflow-x-auto">
                    <table class="min-w-full divide-y divide-gray-200 table-sm-stack">
                        <thead class="bg-gray-50 hidden sm:table-header-group">
                            <tr>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${headers.Name}</th>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${headers.Event}</th>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${headers.Date}</th>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${headers['Type&Result']}</th>
                                <th class="px-3 py-3 text-left text-xs font-medium text-gray-500 uppercase tracking-wider">${headers.Ranking}</th>
                            </tr>
                        </thead>
                        <tbody class="bg-white divide-y divide-gray-200">`;

                uniqueData.forEach(item => {
                    tableHtml += `
                        <tr class="hover:bg-green-50">
                            <td class="px-3 py-2 sm:py-4 whitespace-nowrap sm:whitespace-normal text-sm font-medium text-gray-900" data-label="${headers.Name}">${item.name}</td>
                            <td class="px-3 py-2 sm:py-4 whitespace-nowrap sm:whitespace-normal text-sm text-gray-500" data-label="${headers.Event}">${item.event}</td>
                            <td class="px-3 py-2 sm:py-4 whitespace-nowrap sm:whitespace-normal text-sm text-gray-500" data-label="${headers.Date}">${item.competitionDate}</td>
                            <td class="px-3 py-2 sm:py-4 whitespace-nowrap sm:whitespace-normal text-sm text-green-600 font-semibold" data-label="${headers['Type&Result']}">${item.typeResult}</td>
                            <td class="px-3 py-2 sm:py-4 whitespace-nowrap sm:whitespace-normal text-sm font-bold text-gray-700" data-label="${headers.Ranking}">${item.rankingStr}</td>
                        </tr>
                    `;
                });

                tableHtml += `</tbody></table></div>`;
                return tableHtml;
            };

            // Render both tables
            html += renderTable(hkData, "Hong Kong (Top 10 National PBs)", "National Rank");
            html += renderTable(worldData, "World (Top 5 World PBs)", "World Rank");

            if (!allDataFound) {
                container.innerHTML = `<p class="text-gray-500 italic p-4 bg-gray-50 rounded-lg">No new top personal bests were found achieved between ${startDate} and ${endDate}.</p>`;
            } else {
                container.innerHTML = html;
            }
        }

        // --- Initialization ---
        let futureStartDate, futureEndDate;
        let pastStartDate, pastEndDate;

        function init() {
            const today = new Date();

            // Calculate FUTURE range (Upcoming Competitions)
            const futureStartDt = new Date(today);
            const futureEndDt = new Date(today);
            futureEndDt.setDate(futureEndDt.getDate() + 28); // Next 14 days
            
            futureStartDate = formatDate(futureStartDt);
            futureEndDate = formatDate(futureEndDt);

            // Calculate PAST range (Recent Performances)
            const pastEndDt = new Date(today);
            pastEndDt.setDate(pastEndDt.getDate() - 1); // Yesterday
            const pastStartDt = new Date(pastEndDt);
            pastStartDt.setDate(pastStartDt.getDate() - 27); // 7 days ending yesterday
            
            pastStartDate = formatDate(pastStartDt);
            pastEndDate = formatDate(pastEndDt);
            
            // Display main date range in header
            document.getElementById('dateRangeDisplay').textContent = 
                `Tracking Upcoming: ${futureStartDate} to ${futureEndDate} | Recent Results: ${pastStartDate} to ${pastEndDate}`;

            // Run both trackers simultaneously
            fetchUpcomingCompetitors(futureStartDate, futureEndDate);
            fetchRecentPBs(pastStartDate, pastEndDate);
        }

        document.addEventListener('DOMContentLoaded', init);
    </script>
</body>
</html>
